## Задание 1

Заметим, что для первого сигнала мы обращаемся к неизменяемым данным.
Это значит, что мы можем спокойно распараллелить вычисления по `n` и получить 
корректный ответ.

В то же время, для вычисления очередного значения `y2` нам нужно знать и его
предыдущие значения. То есть, тут уже нельзя распараллелить, надо вычислять значения 
последовательно.

Таким образом, первый сигнал будет проще и быстрее реализовать.

## Задание 2

Заметим, что размерность рабочей группы по третей координате равна 1, значит, 
на эту размерность можно забить.

Размер warp равен 32, что равно размерности по первой координате. 
Значит, внутри одного warp будет все элементы рабочей группы с одинаковым значением 
второй координаты.

Таким образом, внутри одного warp `get_local_id(1) == Const`.
По этой же причине, `get_local_size(1) == 32`. То есть, второе слагаемое 
по модулю не вносит в сумму ничего.

То есть, значение `idx % 32 < 16` зависит только от `get_local_id(1)`, а оно 
внутри одного warp не меняется.

Значит, для всех потоков одного warp результат будет одинаков, и code divergence не будет.

## Задание 3

Заметим, что размерность рабочей группы по третей координате равна 1, значит,
на эту размерность можно забить.

Размер warp равен 32, что равно размерности по первой координате.
Значит, внутри одного warp будет все элементы рабочей группы с одинаковым значением
второй координаты.

Таким образом, внутри одного warp `get_local_id(1) == Const`.
По этой же причине, `get_local_size(1) == 32`, `get_local_size(0) == 32`, 
а `get_local_id(0)` меняется от 0 до 31.

Давайте рассмотрим конкретный warp.
Пусть для него `get_local_id(1) == C`, а `get_local_id(0)` обозначим за `x` (переменная величина).

1) Мы берем `data[x + 32 * C]` элементы. Заметим, что таким образом нам требуется 
32 последовательных элемента. Обращение к памяти coalesced. Они попадают в одну кеш линию (для данного warp, так как `32 * sizeof(float) = 128`), 
значит, рабочей группе надо подгрузить 32 кеш линии.
2) Мы берем `data[C + 32 * x]` элементы. Заметим, что для одного warp это все элементы, 
находящиеся на расстоянии 32 друг от друга. То есть, для получения каждого нового элемента придется 
подгружать отдельную кеш линию. Обращение к памяти не coalesced, а рабочей группе потребуется 
`32 * 32 = 1024` подгруки кеш линий.
3) Мы берем `data[1 + x + 32 * C]` элементы. Они последовательные, но (в отличии от первого пункта) 
есть смещение. То есть, на один warp нужно загрузить 2 кеш линии. Обращение к памяти 
все равно coalesced, а рабочей группе потребуется `2 * 32 = 64` подгрузки кеш линий.